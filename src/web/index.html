<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Loading...</title>
</head>
<body>
<script>
function log(message, scope, level, error = null) {
    const scopeName = scope.asTagName();
    const levelName = level.asTagName();     
    const levelColor = level.asHtmlColor();
                    
    const logMessage = (scope === runtime.Debug.Scope.js) 
        ? `[${scopeName}][${levelName}] ${message}` 
        : message;

    const style = `color: ${levelColor}; font-family: monospace;`;

    if (level === runtime.Debug.Level.err) {
        console.error('%c' + logMessage, style);
        if (error) console.error('Full error:', error);  
    } else if (level === runtime.Debug.Level.warn) {
        console.warn('%c' + logMessage, style);
    } else {
        console.log('%c' + logMessage, style);
    }

    const output = document.getElementById('output');
    if (output) {
        output.innerHTML += `<br><span style="color: ${levelColor}; font-family: monospace;">${logMessage}</span>`;
    }
}

function readString(ptr) {
    const memory = new Uint8Array(wasmExports.memory.buffer);
    let end = ptr;
    while (memory[end] !== 0) end++;
    return new TextDecoder().decode(memory.subarray(ptr, end));
}

async function loadWasm() {
    const importObject = {
        env: {
            getString: (ptr, len) => new TextDecoder().decode(new Uint8Array(wasmExports.memory.buffer, ptr, len)),

            startHotReload: () => {
                if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') return;
                
                let lastSize = 0;
                setInterval(async () => {
                    try {
                        // Check file size
                        const response = await fetch(`./star.wasm?check=${Date.now()}`, { method: 'HEAD' });
                        const contentLength = response.headers.get('content-length');    
                        if (contentLength && parseInt(contentLength) !== lastSize) {
                            lastSize = parseInt(contentLength);
                            log('WASM file changed, hot reloading...', runtime.Debug.Scope.js, runtime.Debug.Level.info);
                            await loadWasm();
                        }
                    } catch (e) {
                        log('HMR check failed:', runtime.Debug.Scope.js, runtime.Debug.Level.err, e);
                    }
                }, 500); 
            },

            wasm_print: (ptr, len, scope_handle, level_handle) => {
                const buffer = new Uint8Array(wasmExports.memory.buffer, ptr, len);
                const message = new TextDecoder().decode(buffer);

                const scope_key = readString(scope_handle);
                const level_key = readString(level_handle);
                
                const scope = window[scope_key];   
                const level = window[level_key];

                log(message, scope, level);         
            },
            
            createElement: (tag_ptr, tag_len) => {
                const tag = importObject.env.getString(tag_ptr, tag_len);
                const el = document.createElement(tag);
                elements.push(el);
                return elements.length - 1;
            },
            
            appendChild: (parent_id, child_id) => {
                if (elements[parent_id] && elements[child_id]) {
                    elements[parent_id].appendChild(elements[child_id]);
                }
            },
            
            setAttribute: (id, name_ptr, name_len, value_ptr, value_len) => {
                const name = importObject.env.getString(name_ptr, name_len);
                const value = importObject.env.getString(value_ptr, value_len);
                if (elements[id]) elements[id].setAttribute(name, value);
            },
            
            addEventListener: (id, event_ptr, event_len, callback_id) => {
                const event = importObject.env.getString(event_ptr, event_len);
                if (elements[id]) {
                    elements[id].addEventListener(event, () => wasmExports.invoke(callback_id));
                }
            },
            
            getValue: (id, buffer_ptr, buffer_len) => {
                if (elements[id] && elements[id].value) {
                    const value = elements[id].value;
                    const bytes = new TextEncoder().encode(value);
                    const copyLen = Math.min(bytes.length, buffer_len);
                    new Uint8Array(wasmExports.memory.buffer).set(bytes.slice(0, copyLen), buffer_ptr);
                    return copyLen;
                }
                return 0;
            },
            
            setInnerHTML: (id, html_ptr, html_len) => {
                const html = importObject.env.getString(html_ptr, html_len);
                if (elements[id]) elements[id].innerHTML = html;
            },
            
            setTextContent: (id, text_ptr, text_len) => {
                const text = importObject.env.getString(text_ptr, text_len);
                if (elements[id]) elements[id].textContent = text;
            },
            
            setClassName: (id, class_ptr, class_len) => {
                const className = importObject.env.getString(class_ptr, class_len);
                if (elements[id]) elements[id].className = className;
            },
            
            setId: (id, id_ptr, id_len) => {
                const elementId = importObject.env.getString(id_ptr, id_len);
                if (elements[id]) elements[id].id = elementId;
            },
            
            setTitle: (title_ptr, title_len) => {
                document.title = importObject.env.getString(title_ptr, title_len);
            },
            
            addStyleSheet: (css_ptr, css_len) => {
                const css = importObject.env.getString(css_ptr, css_len);
                const style = document.createElement('style');
                style.textContent = css;
                document.head.appendChild(style);
            }
        }
    };

    const compileOptions = {
        builtins: ["js-string", "text-encoder"]
    };

    fetch('./star.wasm')
    .then(response => response.arrayBuffer())
    .then(wasmBytes => WebAssembly.compile(wasmBytes, compileOptions))
    .then(wasmModule => WebAssembly.instantiate(wasmModule, importObject))
    .then(wasmInstance => {
        console.log('Loading WebAssembly module...');

        const wasmRawExports = wasmInstance.exports;
        window.wasmExports = {
            ...wasmRawExports,
            runtime: {
                Debug: {}
            }
        };
        console.log('wasmExports: ', window.wasmExports);

        window.runtime = wasmExports.runtime;
        window.elements = [null, document.body];

        const bindingsCode = readString(wasmExports.getJsBindings());
        console.log('bindingsCode: ', bindingsCode);
        eval(bindingsCode);

        if (wasmExports._start) {
            wasmExports._start(); 
        }

        //importObject.env.startHotReload();
    })
    .catch(error => {
        console.log('Error loading WebAssembly: ', error);
    });
}

loadWasm();
</script>
</body>
</html>