<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Star Demo</title>
        <link rel="icon" href="data:,">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        
        <style>
            body{background:#000}
        </style>
    </head>
    <body>
        <js.lib />
        <wasm.lib />
        <script>
            const manifest = {
                name: "Star Terminal",
                short_name: "StarOS",
                display: "standalone",
                start_url: window.location.href, 
                background_color: "#000",
                icons: [{
                    src: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'%3E%3Crect width='192' height='192' fill='%2300ff00'/%3E%3C/svg%3E",
                    sizes: "192x192",
                    type: "image/svg+xml"
                }]
            };
            const manifestUrl = 'data:application/manifest+json,' + encodeURIComponent(JSON.stringify(manifest));
            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = manifestUrl;
            document.head.appendChild(link);
        </script>
        <script>
            let deferredPrompt;
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                console.log('Install prompt ready - press "i" in terminal to install');
            });

            let threads = [];
            let elements = [null, document.body];  // Preserve DOM
            
            async function loadWasm() {
                const isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
                let wasmExports;
                let wasmModule;

                const getString = (ptr, len) => new TextDecoder().decode(new Uint8Array(wasmExports.memory.buffer, ptr, len));

                const dom_op = isWorker ? () => 0 : (op, id, ptr1, len1, ptr2, len2) => {
                    const s1 = len1 ? getString(ptr1, len1) : null;
                    const s2 = len2 ? getString(ptr2, len2) : null;
                    
                    switch(op) {
                        case 0: // createElement
                            const el = document.createElement(s1);
                            elements.push(el);
                            return elements.length - 1;
                            
                        case 1: // appendChild  
                            if (elements[id] && elements[ptr1])
                                elements[id].appendChild(elements[ptr1]);
                            return 0;
                            
                        case 2: // setAttribute
                            if (elements[id]) elements[id].setAttribute(s1, s2);
                            return 0;
                            
                        case 3: // addEventListener
                            if (elements[id]) {
                                elements[id].addEventListener(s1, () => wasmExports.invoke(ptr2));
                            }
                            return 0;
                            
                        case 4: // getValue
                            if (elements[id] && elements[id].value) {
                                const value = elements[id].value;
                                const bytes = new TextEncoder().encode(value);
                                const copyLen = Math.min(bytes.length, len2);
                                new Uint8Array(wasmExports.memory.buffer).set(bytes.slice(0, copyLen), ptr2);
                                return copyLen;
                            }
                            return 0;
                            
                        case 5: // setInnerHTML
                            if (elements[id]) elements[id].innerHTML = s1;
                            return 0;
                            
                        case 6: // setTextContent
                            if (elements[id]) elements[id].textContent = s1;
                            return 0;
                            
                        case 7: // setClassName
                            if (elements[id]) elements[id].className = s1;
                            return 0;
                            
                        case 8: // setId
                            if (elements[id]) elements[id].id = s1;
                            return 0;
                            
                        case 9: // setTitle
                            document.title = s1;
                            return 0;
                            
                        case 10: // addHeadElement
                            const newHeadElement = document.createElement(s2); 
                            newHeadElement.textContent = s1;  
                            document.head.appendChild(newHeadElement);
                            return 0;
                        case 11: // getElementById
                            const elementId = s1;
                            const element = document.getElementById(elementId);
                            if (element) {
                                // Add to elements array and return index
                                elements.push(element);
                                return elements.length - 1;
                            }
                            return 0;  // Not found       
                        default:
                            return 0;
                    }
                };

                const wasm_op = (op, id, ptr1, len1, ptr2, len2) => {
                    const s1 = len1 ? getString(ptr1, len1) : null;
                    const s2 = len2 ? getString(ptr2, len2) : null;
                    
                    switch(op) {
                        case 0: // log
                            console.log('%c' + s1, s2);
                            return 0;
                            
                        case 1: // warn
                            console.warn('%c' + s1, s2);
                            return 0;
                            
                        case 2: // err
                            console.error('%c' + s1, s2);
                            return 0;
                            
                        case 3: // createThread
                            // Terminate old thread 
                            if (threads[id]) {
                                threads[id].terminate();
                            }
                            
                            // Then create new thread
                            const threadCode = `(${loadWasm.toString()})()`;
                            const thread = new Worker(URL.createObjectURL(
                                new Blob([threadCode], { type: 'application/javascript' })
                            ));
                            
                            thread.onmessage = (e) => {
                                if (e.data.type === 'reload-wasm') {
                                    loadWasm();
                                }
                            };
                            
                            threads[id] = thread;
                            
                            thread.postMessage({ type: 'init', module: wasmModule, threadId: id });
                            thread.postMessage({ type: 'run', func_id: id });
                            
                            return id;

                            
                        case 4: // threadJoin
                            if (threads[id]) {
                                threads[id].terminate();
                            }
                            return 0;
                        
                        case 5: // terminalInit
                            if (!isWorker) {
                                // Dispose old terminal if exists
                                if (window.term) {
                                    window.term.dispose();
                                }
                                window.term = new Terminal({
                                    cols: Math.max(80, Math.min(Math.floor(window.innerWidth / 9.2), 132)),
                                    rows: Math.max(24, Math.min(Math.floor(window.innerHeight / 17), 43))
                                });

                                window.term.open(document.getElementById(s1));
                                window.term.onData(data => {
                                    for (let i = 0; i < data.length; i++) {
                                        wasmExports.input_key(data.charCodeAt(i));
                                    }
                                });

                                window.term.element.addEventListener('click', (e) => {
                                    const coords = window.term.buffer.active;
                                    const lineText = window.term.buffer.active.getLine(coords.cursorY)?.translateToString() || '';
                                    
                                    if (lineText.includes('[Install]') || lineText.includes('Install')) {
                                        if (deferredPrompt) {
                                            deferredPrompt.prompt();
                                            deferredPrompt.userChoice.then(result => {
                                                window.term.writeln(`\r\nâœ… Install ${result.outcome === 'accepted' ? 'successful!' : 'cancelled'}`);
                                                deferredPrompt = null;
                                            });
                                        } else if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                                            window.term.writeln('\r\nðŸ“± iOS: Tap Share â†’ Add to Home Screen');
                                        } else {
                                            window.term.writeln('\r\nâœ… Already installed or not available');
                                        }
                                    }
                                });
                            }
                            return 0;
                        case 6: // terminalWrite
                            if (isWorker) {
                                postMessage({type: 'terminal', text: s1});
                            } else {
                                if (window.term) window.term.write(s1);
                            }
                            return 0;
                            
                        case 7: // fetch
                            const url = s1;
                            const method = s2;
                            const fetchUrl = location.origin + '/star.wasm?check=' + Date.now();
                            fetch(fetchUrl, { method: method })
                                .then(r => {
                                    const contentLength = r.headers.get('content-length');
                                    const lastModified = r.headers.get('last-modified');
                                    const size = contentLength ? parseInt(contentLength) : 0;
                                    
                                    let hash = 0;
                                    if (lastModified) {
                                        for (let i = 0; i < lastModified.length; i++) {
                                            hash = ((hash << 5) - hash) + lastModified.charCodeAt(i);
                                            hash = hash >>> 0; 
                                        }
                                    }
                                    
                                    // Combine size and hash with XOR
                                    const value = (size ^ hash) >>> 0;
                                    wasmExports.fetch_callback(id, value);
                                })
                                .catch(err => {
                                    console.error('Fetch error:', err);
                                    wasmExports.fetch_callback(id, 0);
                                });
                            return 0;

                        case 8: // sleep
                            // TODO: consider Atomics.wait without SAB
                            //       for now, just use setTimeout in worker
                            const ms = id;
                            const func_id = len1; 
                            setTimeout(() => wasmExports.sleep_callback(func_id), ms);
                            return 0;

                        case 9: // reloadWasm
                            if (isWorker) {
                                postMessage({type: 'reload-wasm'}); 
                            } else {
                                loadWasm();
                            }
                            return 0;

                        default:
                            return 0;
                    }
                };

                const importObject = {
                    env: {
                        dom_op: dom_op,
                        wasm_op: wasm_op,
                    }
                };
                
                if (isWorker) {
                    onmessage = async function(e) {
                        if (e.data.type === 'init') {
                            wasmModule = e.data.module;
                            const wasmInstance = await WebAssembly.instantiate(wasmModule, importObject);
                            wasmExports = wasmInstance.exports;
                        } 
                        else if (e.data.type === 'run') {
                            if (wasmExports) {
                                wasmExports.invoke_thread(e.data.func_id);
                            }
                        }
                    };
                } else {
                    // Check if WASM is embedded in the page
                    const embeddedWasm = typeof EMBEDDED_WASM !== 'undefined' ? EMBEDDED_WASM : null;
                    
                    const wasmPromise = embeddedWasm 
                        ? Promise.resolve(Uint8Array.from(atob(embeddedWasm), c => c.charCodeAt(0)).buffer)
                        : fetch('./star.wasm').then(response => response.arrayBuffer());
                    
                    wasmPromise
                    .then(wasmBytes => WebAssembly.compile(wasmBytes))
                    .then(module => {
                        wasmModule = module;
                        return WebAssembly.instantiate(module, importObject);
                    })
                    .then(instance => {
                        wasmExports = instance.exports;
                        
                        if (wasmExports._start) {
                            wasmExports.configure(location.hostname === 'localhost' || location.hostname === '127.0.0.1');
                            //console.log('wasmExports: ', wasmExports);
                            wasmExports._start();
                        }
                    })
                    .catch(error => {
                        console.log('Error loading WebAssembly:', error);
                    });
                }
            }
            loadWasm();
        </script>
    </body>
</html>