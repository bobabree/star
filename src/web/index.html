<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>StarOS</title>

        <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'%3E%3Crect width='192' height='192' fill='%23000'/%3E%3Cpath d='M96 36 L111 79 L159 79 L121 109 L137 152 L96 120 L55 152 L71 109 L33 79 L81 79 Z' fill='none' stroke='%2300FF00' stroke-width='3'/%3E%3C/svg%3E">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        
        <style>
            body{background:#000}
        </style>
    </head>
    <body>
        <js.lib />
        <wasm.lib />
        <script>
            const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';

            const manifest = {
                name: "Star Terminal",
                short_name: "StarOS",
                display: "standalone",
                start_url: window.location.href, 
                background_color: "#000",
                theme_color: "#000",
                icons: isLocal ? [
                    {
                        src: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' fill='%23000'/%3E%3Cpath d='M256 96 L296 211 L424 211 L323 291 L365 405 L256 320 L147 405 L189 291 L88 211 L216 211 Z' fill='none' stroke='%2300FF00' stroke-width='8'/%3E%3C/svg%3E",
                        sizes: "any",
                        type: "image/svg+xml",
                        purpose: "any maskable"
                    }
                ] : [
                    {
                        src: "https://bobabree.github.io/star/icon-192.png",
                        sizes: "192x192",
                        type: "image/png"
                    },
                    {
                        src: "https://bobabree.github.io/star/icon-512.png",
                        sizes: "512x512",
                        type: "image/png"
                    }
                ]
            };
            const manifestUrl = 'data:application/manifest+json,' + encodeURIComponent(JSON.stringify(manifest));
            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = manifestUrl;
            document.head.appendChild(link);

            const appleIcon = document.createElement('link');
            appleIcon.rel = 'apple-touch-icon';
            appleIcon.href = isLocal 
                ? "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'%3E%3Crect width='192' height='192' fill='%23000'/%3E%3Cpath d='M96 36 L111 79 L159 79 L121 109 L137 152 L96 120 L55 152 L71 109 L33 79 L81 79 Z' fill='none' stroke='%2300FF00' stroke-width='3'/%3E%3C/svg%3E"
                : "https://bobabree.github.io/star/icon-192.png";
            document.head.appendChild(appleIcon);
        </script>
        <script>
            let threads = [];
            let elements = [null, document.body];  // Preserve DOM
            
            async function loadWasm() {
                const isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
                let wasmExports;
                let wasmModule;

                const getString = (ptr, len) => new TextDecoder().decode(new Uint8Array(wasmExports.memory.buffer, ptr, len));

                const dom_op = isWorker ? () => 0 : (op, id, ptr1, len1, ptr2, len2) => {
                    const s1 = len1 ? getString(ptr1, len1) : null;
                    const s2 = len2 ? getString(ptr2, len2) : null;
                    
                    switch(op) {
                        case 0: // createElement
                            const el = document.createElement(s1);
                            elements.push(el);
                            return elements.length - 1;
                            
                        case 1: // appendChild  
                            if (elements[id] && elements[ptr1])
                                elements[id].appendChild(elements[ptr1]);
                            return 0;
                            
                        case 2: // setAttribute
                            if (elements[id]) elements[id].setAttribute(s1, s2);
                            return 0;
                            
                        case 3: // addEventListener
                            if (elements[id]) {
                                elements[id].addEventListener(s1, () => wasmExports.invoke(ptr2));
                            }
                            return 0;
                            
                        case 4: // getValue
                            if (elements[id] && elements[id].value) {
                                const value = elements[id].value;
                                const bytes = new TextEncoder().encode(value);
                                const copyLen = Math.min(bytes.length, len2);
                                new Uint8Array(wasmExports.memory.buffer).set(bytes.slice(0, copyLen), ptr2);
                                return copyLen;
                            }
                            return 0;
                            
                        case 5: // setInnerHTML
                            if (elements[id]) elements[id].innerHTML = s1;
                            return 0;
                            
                        case 6: // setTextContent
                            if (elements[id]) elements[id].textContent = s1;
                            return 0;
                            
                        case 7: // setClassName
                            if (elements[id]) elements[id].className = s1;
                            return 0;
                            
                        case 8: // setId
                            if (elements[id]) elements[id].id = s1;
                            return 0;
                            
                        case 9: // setTitle
                            document.title = s1;
                            return 0;
                            
                        case 10: // addHeadElement
                            const newHeadElement = document.createElement(s2); 
                            newHeadElement.textContent = s1;  
                            document.head.appendChild(newHeadElement);
                            return 0;
                        case 11: // getElementById
                            const elementId = s1;
                            const element = document.getElementById(elementId);
                            if (element) {
                                // Add to elements array and return index
                                elements.push(element);
                                return elements.length - 1;
                            }
                            return 0;  // Not found       
                        default:
                            return 0;
                    }
                };

                const wasm_op = (op, id, ptr1, len1, ptr2, len2) => {
                    const s1 = len1 ? getString(ptr1, len1) : null;
                    const s2 = len2 ? getString(ptr2, len2) : null;
                    
                    switch(op) {
                        case 0: // log
                            console.log('%c' + s1, s2);
                            return 0;
                            
                        case 1: // warn
                            console.warn('%c' + s1, s2);
                            return 0;
                            
                        case 2: // err
                            console.error('%c' + s1, s2);
                            return 0;
                            
                        case 3: // createThread
                            // Terminate old thread 
                            if (threads[id]) {
                                threads[id].terminate();
                            }
                            
                            // Then create new thread
                            const threadCode = `(${loadWasm.toString()})()`;
                            const thread = new Worker(URL.createObjectURL(
                                new Blob([threadCode], { type: 'application/javascript' })
                            ));
                            
                            thread.onmessage = (e) => {
                                if (e.data.type === 'reload-wasm') {
                                    loadWasm();
                                }
                            };
                            
                            threads[id] = thread;
                            
                            thread.postMessage({ type: 'init', module: wasmModule, threadId: id });
                            thread.postMessage({ type: 'run', func_id: id });
                            
                            return id;

                            
                        case 4: // threadJoin
                            if (threads[id]) {
                                threads[id].terminate();
                            }
                            return 0;
                        
                        case 5: // terminalInit
                            if (!isWorker) {
                                // Dispose old terminal if exists
                                if (window.term) {
                                    window.term.dispose();
                                }
                                window.term = new Terminal({
                                    cols: Math.max(80, Math.min(Math.floor(window.innerWidth / 9.2), 132)),
                                    rows: Math.max(24, Math.min(Math.floor(window.innerHeight / 17), 43))
                                });

                                if (!window.deferredPrompt) {
                                    window.addEventListener('beforeinstallprompt', (e) => {
                                        e.preventDefault();
                                        window.deferredPrompt = e;
                                    });
                                }

                                window.term.options.linkHandler = {
                                    activate: (event, text, range) => {
                                        if (text === '//install') {
                                            // Check if already installed
                                            const isInstalled = window.navigator.standalone || 
                                                window.matchMedia('(display-mode: standalone)').matches ||
                                                window.matchMedia('(display-mode: fullscreen)').matches;
                                
                                            if (isInstalled) {
                                                window.term.write('\r\n\x1b[32m[✓] Already installed!\x1b[0m');
                                            } else if (window.deferredPrompt) {
                                                window.deferredPrompt.prompt();
                                                window.deferredPrompt = null;
                                            } else {
                                                // Check if iOS
                                                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                                                
                                                if (isIOS) {
                                                    window.term.write('\r\nTo install Star Terminal on iPhone/iPad:\r\n');
                                                    window.term.write('   1. Tap the Share button \r\n');
                                                    window.term.write('   2. Scroll down and tap ');
                                                    window.term.write('\x1b[1;36m"Add to Home Screen"\x1b[0m\r\n');
                                                    window.term.write('\r\nThe app icon will appear on your home screen.');
                                                } else {
                                                    window.term.write('\r\nTo install Star Terminal:\r\n');
                                                    window.term.write('   • Chrome/Edge: Look for install icon in address bar\r\n');
                                                    window.term.write('   • Firefox: Click ••• menu → Install\r\n');
                                                    window.term.write('   • Safari: File → Add to Dock');
                                                }
                                            }
                                            setTimeout(() => wasmExports.input_key(13), 100);
                                        }
                                    },
                                    allowNonHttpProtocols: true
                                };

                                window.term.open(document.getElementById(s1));
                                window.term.onData(data => {
                                    for (let i = 0; i < data.length; i++) {
                                        wasmExports.input_key(data.charCodeAt(i));
                                    }
                                });
                            }
                            return 0;
                        case 6: // terminalWrite
                            if (isWorker) {
                                postMessage({type: 'terminal', text: s1});
                            } else {
                                if (window.term) window.term.write(s1);
                            }
                            return 0;
                            
                        case 7: // fetch
                            const url = s1;
                            const method = s2;

                            if (id === 100) { // fetch
                                fetch(url)
                                    .then(r => {
                                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                                        return r.arrayBuffer();
                                    })
                                    .then(data => {
                                        const bytes = new Uint8Array(data);
                                        const contentId = Date.now() >>> 0; 
                                        
                                        const req = indexedDB.open('StarOS', 1);
                                        req.onupgradeneeded = e => {
                                            const db = e.target.result;
                                            if (!db.objectStoreNames.contains('fs'))
                                                db.createObjectStore('fs');
                                        };
                                        req.onsuccess = () => {
                                            const db = req.result;
                                            const tx = db.transaction(['fs'], 'readwrite');
                                            tx.objectStore('fs').put(bytes, 'file_' + contentId);
                                            tx.oncomplete = () => {
                                                db.close();
                                                wasmExports.fetch_callback(contentId, bytes.length);
                                            };
                                        };
                                    })
                                    .catch(err => {
                                        console.error('Download failed:', err);
                                        wasmExports.fetch_callback(0, 0); // Signal failure
                                    });
                                return 0;
                            }

                            const fetchUrl = location.origin + '/star.wasm?check=' + Date.now();
                            fetch(fetchUrl, { method: method })
                                .then(r => {
                                    const contentLength = r.headers.get('content-length');
                                    const lastModified = r.headers.get('last-modified');
                                    const size = contentLength ? parseInt(contentLength) : 0;
                                    
                                    let hash = 0;
                                    if (lastModified) {
                                        for (let i = 0; i < lastModified.length; i++) {
                                            hash = ((hash << 5) - hash) + lastModified.charCodeAt(i);
                                            hash = hash >>> 0; 
                                        }
                                    }
                                    
                                    // Combine size and hash with XOR
                                    const value = (size ^ hash) >>> 0;
                                    wasmExports.reload_wasm_callback(id, value);
                                })
                                .catch(err => {
                                    console.error('Fetch error:', err);
                                    wasmExports.reload_wasm_callback(id, 0);
                                });
                            return 0;

                        case 8: // sleep
                            // TODO: consider Atomics.wait without SAB
                            //       for now, just use setTimeout in worker
                            const ms = id;
                            const func_id = len1; 
                            setTimeout(() => wasmExports.sleep_callback(func_id), ms);
                            return 0;

                        case 9: // reloadWasm
                            if (isWorker) {
                                postMessage({type: 'reload-wasm'}); 
                            } else {
                                loadWasm();
                            }
                            return 0;

                        case 10: // save
                            const key = s1;
                            const data = new Uint8Array(wasmExports.memory.buffer, ptr2, len2);
                            
                            (async () => {
                                const req = indexedDB.open('StarOS', 1);
                                req.onupgradeneeded = e => {
                                    const db = e.target.result;
                                    if (!db.objectStoreNames.contains('fs'))
                                        db.createObjectStore('fs');
                                };
                                req.onsuccess = () => {
                                    const db = req.result;
                                    const tx = db.transaction(['fs'], 'readwrite');
                                    tx.objectStore('fs').put(data, key);
                                    tx.oncomplete = () => db.close();
                                };
                            })();
                            return 0;
    
                        case 11: // load  
                            const loadKey = s1;
                            const callback_id = id;                        
                            const req = indexedDB.open('StarOS', 1);
                            req.onupgradeneeded = e => {
                                const db = e.target.result;
                                if (!db.objectStoreNames.contains('fs'))
                                    db.createObjectStore('fs');
                            };
                            req.onsuccess = () => {
                                const db = req.result;
                                const tx = db.transaction(['fs'], 'readonly');
                                const getReq = tx.objectStore('fs').get(loadKey);
                                
                                getReq.onsuccess = () => {
                                    try {
                                        const data = getReq.result;
                                        if (data) {
                                            const bytes = new Uint8Array(data);
                                            
                                            if (callback_id === 200) { // cmd command
                                                const text = new TextDecoder().decode(bytes);
                                                if (window.term) window.term.write(text + '\r\n');
                                                wasmExports.cmd_callback();
                                            } else {
                                                const ptr = wasmExports.memory.buffer.byteLength - bytes.length;
                                                new Uint8Array(wasmExports.memory.buffer).set(bytes, ptr);
                                                wasmExports.fs_callback(callback_id, ptr, bytes.length);
                                            }
                                        } else {
                                            if (callback_id === 200) {
                                                if (window.term) window.term.write('cat: file not found\r\n');
                                                wasmExports.cmd_callback();
                                            } else {
                                                wasmExports.fs_callback(callback_id, 0, 0);
                                            }
                                        }
                                        db.close();
                                    } catch (err) {
                                        console.error('Load operation failed:', err);
                                        db.close();

                                        indexedDB.deleteDatabase('StarOS').onsuccess = () => {
                                            if (window.term) window.term.write('Database corrupted and resetted.\r\n');
                                            if (callback_id === 200) {
                                                wasmExports.cmd_callback();
                                            } else {
                                                wasmExports.fs_callback(callback_id, 0, 0);
                                            }
                                        };
                                    }
                                };
                                
                                getReq.onerror = () => {
                                    console.error('Failed to read from IndexedDB');
                                    wasmExports.fs_callback(callback_id, 0, 0);
                                    db.close();
                                };
                            };
                            req.onerror = () => {
                                console.error('Failed to open IndexedDB');
                                wasmExports.fs_callback(callback_id, 0, 0);
                            };
                            return 0;

                        default:
                            return 0;
                    }
                };

                const importObject = {
                    env: {
                        dom_op: dom_op,
                        wasm_op: wasm_op,
                    }
                };
                
                if (isWorker) {
                    onmessage = async function(e) {
                        if (e.data.type === 'init') {
                            wasmModule = e.data.module;
                            const wasmInstance = await WebAssembly.instantiate(wasmModule, importObject);
                            wasmExports = wasmInstance.exports;
                        } 
                        else if (e.data.type === 'run') {
                            if (wasmExports) {
                                wasmExports.invoke_thread(e.data.func_id);
                            }
                        }
                    };
                } else {
                    // Check if WASM is embedded in the page
                    const embeddedWasm = typeof EMBEDDED_WASM !== 'undefined' ? EMBEDDED_WASM : null;
                    
                    const wasmPromise = embeddedWasm 
                        ? Promise.resolve(Uint8Array.from(atob(embeddedWasm), c => c.charCodeAt(0)).buffer)
                        : fetch('./star.wasm').then(response => response.arrayBuffer());
                    
                    wasmPromise
                    .then(wasmBytes => WebAssembly.compile(wasmBytes))
                    .then(module => {
                        wasmModule = module;
                        return WebAssembly.instantiate(module, importObject);
                    })
                    .then(instance => {
                        wasmExports = instance.exports;
                        
                        if (wasmExports._start) {
                            wasmExports.configure(location.hostname === 'localhost' || location.hostname === '127.0.0.1');
                            //console.log('wasmExports: ', wasmExports);
                            wasmExports._start();
                        }
                    })
                    .catch(error => {
                        console.log('Error loading WebAssembly:', error);
                    });
                }
            }
            loadWasm();
        </script>
    </body>
</html>