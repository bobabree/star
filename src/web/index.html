<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Star Demo</title>
        <link rel="icon" href="data:,">
        <style>
            body{background:#000}
        </style>
    </head>
    <body>
        <js.lib />
        <wasm.lib />
        <script>
            let threads = [];
            let elements = [null, document.body];  // Preserve DOM
            
            async function loadWasm() {
                const isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
                let wasmExports;
                let wasmModule;

                const getString = (ptr, len) => new TextDecoder().decode(new Uint8Array(wasmExports.memory.buffer, ptr, len));

                const dom_op = isWorker ? () => 0 : (op, id, ptr1, len1, ptr2, len2) => {
                    const s1 = len1 ? getString(ptr1, len1) : null;
                    const s2 = len2 ? getString(ptr2, len2) : null;
                    
                    switch(op) {
                        case 0: // createElement
                            const el = document.createElement(s1);
                            elements.push(el);
                            return elements.length - 1;
                            
                        case 1: // appendChild  
                            if (elements[id] && elements[ptr1])
                                elements[id].appendChild(elements[ptr1]);
                            return 0;
                            
                        case 2: // setAttribute
                            if (elements[id]) elements[id].setAttribute(s1, s2);
                            return 0;
                            
                        case 3: // addEventListener
                            if (elements[id]) {
                                elements[id].addEventListener(s1, () => wasmExports.invoke(ptr2));
                            }
                            return 0;
                            
                        case 4: // getValue
                            if (elements[id] && elements[id].value) {
                                const value = elements[id].value;
                                const bytes = new TextEncoder().encode(value);
                                const copyLen = Math.min(bytes.length, len2);
                                new Uint8Array(wasmExports.memory.buffer).set(bytes.slice(0, copyLen), ptr2);
                                return copyLen;
                            }
                            return 0;
                            
                        case 5: // setInnerHTML
                            if (elements[id]) elements[id].innerHTML = s1;
                            return 0;
                            
                        case 6: // setTextContent
                            if (elements[id]) elements[id].textContent = s1;
                            return 0;
                            
                        case 7: // setClassName
                            if (elements[id]) elements[id].className = s1;
                            return 0;
                            
                        case 8: // setId
                            if (elements[id]) elements[id].id = s1;
                            return 0;
                            
                        case 9: // setTitle
                            document.title = s1;
                            return 0;
                            
                        case 10: // addHeadElement
                            const newHeadElement = document.createElement(s2); 
                            newHeadElement.textContent = s1;  
                            document.head.appendChild(newHeadElement);
                            return 0;
                        case 11: // getElementById
                            const elementId = s1;
                            const element = document.getElementById(elementId);
                            if (element) {
                                // Add to elements array and return index
                                elements.push(element);
                                return elements.length - 1;
                            }
                            return 0;  // Not found       
                        default:
                            return 0;
                    }
                };

                const wasm_op = (op, id, ptr1, len1, ptr2, len2) => {
                    const s1 = len1 ? getString(ptr1, len1) : null;
                    const s2 = len2 ? getString(ptr2, len2) : null;
                    
                    switch(op) {
                        case 0: // log
                            console.log('%c' + s1, s2);
                            return 0;
                            
                        case 1: // warn
                            console.warn('%c' + s1, s2);
                            return 0;
                            
                        case 2: // err
                            console.error('%c' + s1, s2);
                            return 0;
                            
                        case 3: // createThread
                            // Terminate old thread 
                            if (threads[id]) {
                                threads[id].terminate();
                            }
                            
                            // Then create new thread
                            const threadCode = `(${loadWasm.toString()})()`;
                            const thread = new Worker(URL.createObjectURL(
                                new Blob([threadCode], { type: 'application/javascript' })
                            ));
                            
                            thread.onmessage = (e) => {
                                if (e.data.type === 'reload-wasm') {
                                    loadWasm();
                                }
                            };
                            
                            threads[id] = thread;
                            
                            thread.postMessage({ type: 'init', module: wasmModule, threadId: id });
                            thread.postMessage({ type: 'run', task_id: id });
                            
                            return id;

                            
                        case 4: // threadJoin
                            if (threads[id]) {
                                threads[id].terminate();
                            }
                            return 0;
                        
                        case 5: // terminalInit
                            if (!isWorker) {
                                // Dispose old terminal if exists
                                if (window.term) {
                                    window.term.dispose();
                                }
                                window.term = new Terminal({
                                    cols: Math.floor(window.innerWidth / 9.2),
                                });
                                window.term.open(document.getElementById(s1));
                                window.term.onData(data => {
                                    for (let i = 0; i < data.length; i++) {
                                        wasmExports.terminal_key(data.charCodeAt(i));
                                    }
                                });
                            }
                            return 0;
                        case 6: // terminalWrite
                            if (isWorker) {
                                postMessage({type: 'terminal', text: s1});
                            } else {
                                if (window.term) window.term.write(s1);
                            }
                            return 0;
                            
                        case 7: // fetch
                            const url = s1;
                            const method = s2;
                            const baseUrl = location.origin === 'null' ? '' : location.origin;
                            const fetchUrl = baseUrl + '/star.wasm?check=' + Date.now();
                            fetch(fetchUrl, { method: method })
                                .then(r => {
                                    const contentLength = r.headers.get('content-length');
                                    const size = contentLength ? parseInt(contentLength) : 0;
                                    wasmExports.fetch_callback(id, size);
                                })
                                .catch(err => {
                                    // TODO: for now, ignore errors in standalone mode
                                    if (location.protocol !== 'file:') {
                                        console.error('Fetch error:', err);
                                    }
                                    wasmExports.fetch_callback(id, 0);
                                });
                        return 0;

                        case 8: // sleep
                            // TODO: consider Atomics.wait without SAB
                            //       for now, just use setTimeout in worker
                            setTimeout(() => wasmExports.sleep_callback(), id);
                            return 0;

                        case 9: // reloadWasm
                            if (isWorker) {
                                postMessage({type: 'reload-wasm'}); 
                            } else {
                                loadWasm();
                            }
                            return 0;

                        default:
                            return 0;
                    }
                };

                const importObject = {
                    env: {
                        dom_op: dom_op,
                        wasm_op: wasm_op,
                    }
                };
                
                if (isWorker) {
                    onmessage = async function(e) {
                        if (e.data.type === 'init') {
                            wasmModule = e.data.module;
                            const wasmInstance = await WebAssembly.instantiate(wasmModule, importObject);
                            wasmExports = wasmInstance.exports;
                        } 
                        else if (e.data.type === 'run') {
                            if (wasmExports) {
                                wasmExports.invoke_thread_task(e.data.task_id);
                            }
                        }
                    };
                } else {
                    // Check if WASM is embedded in the page
                    const embeddedWasm = typeof EMBEDDED_WASM !== 'undefined' ? EMBEDDED_WASM : null;
                    
                    const wasmPromise = embeddedWasm 
                        ? Promise.resolve(Uint8Array.from(atob(embeddedWasm), c => c.charCodeAt(0)).buffer)
                        : fetch('./star.wasm').then(response => response.arrayBuffer());
                    
                    wasmPromise
                    .then(wasmBytes => WebAssembly.compile(wasmBytes))
                    .then(module => {
                        wasmModule = module;
                        return WebAssembly.instantiate(module, importObject);
                    })
                    .then(instance => {
                        wasmExports = instance.exports;
                        
                        if (wasmExports._start) {
                            //console.log('wasmExports: ', wasmExports);
                            wasmExports._start();
                        }
                    })
                    .catch(error => {
                        console.log('Error loading WebAssembly:', error);
                    });
                }
            }
            loadWasm();
        </script>
    </body>
</html>