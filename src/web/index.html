<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Loading...</title>
    <link rel="icon" href="data:,">
</head>
<body>
<script>
async function loadWasm() {
    const read = (memory, ptr, len) => new TextDecoder().decode(new Uint8Array(memory.buffer, ptr, len));

    const log = (memory, consoleFunc, msgPtr, msgLen, stylePtr, styleLen) => {
        const message = read(memory, msgPtr, msgLen);
        const style = read(memory, stylePtr, styleLen);
        consoleFunc('%c' + message, style);
    };

    const makeImports = () => ({
        console_log: (msgPtr, msgLen, stylePtr, styleLen) => log(wasmExports.memory, console.log, msgPtr, msgLen, stylePtr, styleLen),
        console_warn: (msgPtr, msgLen, stylePtr, styleLen) => log(wasmExports.memory, console.warn, msgPtr, msgLen, stylePtr, styleLen),
        console_error: (msgPtr, msgLen, stylePtr, styleLen) => log(wasmExports.memory, console.error, msgPtr, msgLen, stylePtr, styleLen),
    });

    const importObject = {
        env: {
            ...makeImports(),
            reload_wasm: () => loadWasm(),
            threadTask: function() {
                let wasmInstance;
                onmessage = async function(e) {
                    if (e.data.type === 'init') {
                        const module = e.data.module;
                        const threadId = e.data.threadId; 

                        const read = (memory, ptr, len) => new TextDecoder().decode(new Uint8Array(memory.buffer, ptr, len));
                        
                        const log = (memory, consoleFunc, msgPtr, msgLen, stylePtr, styleLen) => {
                            const message = read(memory, msgPtr, msgLen);
                            const style = read(memory, stylePtr, styleLen);
                            consoleFunc('%c' + message, style);
                        };

                        const makeImports = () => ({
                            console_log: (msgPtr, msgLen, stylePtr, styleLen) => log(wasmInstance.exports.memory, console.log, msgPtr, msgLen, stylePtr, styleLen),
                            console_warn: (msgPtr, msgLen, stylePtr, styleLen) => log(wasmInstance.exports.memory, console.warn, msgPtr, msgLen, stylePtr, styleLen),
                            console_error: (msgPtr, msgLen, stylePtr, styleLen) => log(wasmInstance.exports.memory, console.error, msgPtr, msgLen, stylePtr, styleLen),
                        });
                        
                        // Define all the stubs the thread needs
                        const threadImportObject = {
                            env: {
                                ...makeImports(),
                                setTitle: function() {},
                                createElement: function() { return 0; },
                                appendChild: function() {},
                                setAttribute: function() {},
                                addEventListener: function() {},
                                getValue: function() { return 0; },
                                setInnerHTML: function() {},
                                setTextContent: function() {},
                                setClassName: function() {},
                                setId: function() {},
                                addStyleSheet: function() {},
                                reload_wasm: function() {},
                                create_thread: function() { return 0; },
                                thread_join: function() {}
                            }
                        };
                        
                        wasmInstance = await WebAssembly.instantiate(module, threadImportObject);
                    } else if (e.data.type === 'run') {
                        try {
                            wasmInstance.exports.invoke_thread_task(e.data.task_id);
                        } catch (error) {
                            console.error('Error calling invoke_thread_task:', error);
                        }
                    }
                };
            },
            
            create_thread: (task_id) => {
                const threadTask = `(${importObject.env.threadTask.toString()})()`;
                const thread = new Worker(URL.createObjectURL(
                    new Blob([threadTask], { type: 'application/javascript' })
                ));
                const threadId = threads.length;
                
                thread.postMessage({ type: 'init', module: wasmModule, threadId: threadId });
                thread.postMessage({ type: 'run', task_id: task_id });
                
                threads.push(thread);
                return threadId;
            },

            thread_join: (thread_id) => {
                if (threads[thread_id]) {
                    threads[thread_id].terminate();
                }
            },
            
            createElement: (tag_ptr, tag_len) => {
                const tag = read(wasmExports.memory, tag_ptr, tag_len);
                const el = document.createElement(tag);
                elements.push(el);
                return elements.length - 1;
            },
            
            appendChild: (parent_id, child_id) => {
                if (elements[parent_id] && elements[child_id]) {
                    elements[parent_id].appendChild(elements[child_id]);
                }
            },
            
            setAttribute: (id, name_ptr, name_len, value_ptr, value_len) => {
                const name = read(wasmExports.memory, name_ptr, name_len);
                const value = read(wasmExports.memory, value_ptr, value_len);
                if (elements[id]) elements[id].setAttribute(name, value);
            },
            
            addEventListener: (id, event_ptr, event_len, callback_id) => {
                const event = read(wasmExports.memory, event_ptr, event_len);
                if (elements[id]) {
                    elements[id].addEventListener(event, () => wasmExports.invoke(callback_id));
                }
            },
            
            getValue: (id, buffer_ptr, buffer_len) => {
                if (elements[id] && elements[id].value) {
                    const value = elements[id].value;
                    const bytes = new TextEncoder().encode(value);
                    const copyLen = Math.min(bytes.length, buffer_len);
                    new Uint8Array(wasmExports.memory.buffer).set(bytes.slice(0, copyLen), buffer_ptr);
                    return copyLen;
                }
                return 0;
            },
            
            setInnerHTML: (id, html_ptr, html_len) => {
                const html = read(wasmExports.memory, html_ptr, html_len);
                if (elements[id]) elements[id].innerHTML = html;
            },
            
            setTextContent: (id, text_ptr, text_len) => {
                const text = read(wasmExports.memory, text_ptr, text_len);
                if (elements[id]) elements[id].textContent = text;
            },
            
            setClassName: (id, class_ptr, class_len) => {
                const className = read(wasmExports.memory, class_ptr, class_len);
                if (elements[id]) elements[id].className = className;
            },
            
            setId: (id, id_ptr, id_len) => {
                const elementId = read(wasmExports.memory, id_ptr, id_len);
                if (elements[id]) elements[id].id = elementId;
            },
            
            setTitle: (title_ptr, title_len) => {
                document.title = read(wasmExports.memory, title_ptr, title_len);
            },
            
            addStyleSheet: (css_ptr, css_len) => {
                const css = read(wasmExports.memory, css_ptr, css_len);
                const style = document.createElement('style');
                style.textContent = css;
                document.head.appendChild(style);
            }
        }
    };

    const compileOptions = {
        builtins: ["js-string", "text-encoder"]
    };

    fetch('./star.wasm')
    .then(response => response.arrayBuffer())
    .then(wasmBytes => WebAssembly.compile(wasmBytes, compileOptions))
    .then(wasmModule => {
        window.wasmModule = wasmModule; 
        return WebAssembly.instantiate(wasmModule, importObject);
    })
    .then(wasmInstance => {
        console.log('Loading WebAssembly module...');

        window.wasmExports = {
            ...wasmInstance.exports,
        };
        window.elements = [null, document.body];
        window.threads = [];

        if (wasmExports._start) {
            wasmExports._start(); 
        }
    })
    .catch(error => {
        console.log('Error loading WebAssembly: ', error);
    });
}

loadWasm();
</script>
</body>
</html>